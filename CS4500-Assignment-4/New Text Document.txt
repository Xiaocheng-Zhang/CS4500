class ColumnVec : public Vec {
public:
  Column **list_;

  ColumnVec() : Vec() {
    list_ = new Column *[capacity_];
    initialize(0);
  }

  ~ColumnVec() { delete[] list_; }

  void initialize(size_t idx) {
    for (size_t i = idx; i < capacity_; i++) {
      list_[i] = nullptr;
    }
  }

  void expand() {
    if (size_ == capacity_) {
      capacity_ *= 2;
      Column **temp = new Column *[capacity_];
      for (size_t i = 0; i < size_; i++) {
        temp[i] = list_[i];
      }
      delete[] list_;
      list_ = temp;
      initialize(size_);
    }
    assert(size_ < capacity_);
  }

  virtual void append(Column *col) {
    expand();
    Column *colcpy = new Column();
    colcpy->val_ = col->val_->copy();
    list_[size_] = colcpy;
    size_++;
  }

  virtual void set(size_t idx, Column *col) {
    expand();
    Column *colcpy = new Column();
    colcpy->val_ = col->val_->copy();
    list_[idx] = colcpy; // v->copy();
  }

  virtual void insert(size_t idx, Column *col) {
    expand();
    Column **temp = new Column *[capacity_];
    size_++;
    for (size_t i = 0, j = idx; i < size_; i++) {
      if (i < j) {
        temp[i] = list_[i];
      } else if (i == j) {
        Column *colcpy = new Column();
        colcpy->val_ = col->val_->copy();
        temp[i] = colcpy; // v->copy();
      } else {
        temp[i] = list_[j];
        j++;
      }
    }
    delete[] list_;
    list_ = temp;
  }
  virtual bool contains(Column *col) {
    for (size_t m = 0; m < size_; m++) {
      if (list_[m]->equals(col)) {
        return true;
      }
    }
    return false;
  }

  virtual int indexAt(Column *col) {
    for (size_t m = 0; m < size_; m++) {
      if (list_[m]->equals(col)) {
        return m;
      }
    }
    return -1;
  }
  virtual void del(size_t idx) {
    Column **temp = new Column *[capacity_];
    for (size_t i = 0, j = idx; i < size_; i++) {
      if (i < j) {
        temp[i] = list_[i];
      } else if (i > j) {
        temp[j] = list_[i];
        j++;
      }
    }
    size_--;
    delete[] list_;
    list_ = temp;
  }
  virtual Vec *copy() {
    ColumnVec *temp = new ColumnVec();
    for (size_t i = 0; i < size_; i++) {
      temp->append(list_[i]);
    }
    return temp;
  }
  /**
   * overrite hash_me to hash the code.
   * @return return hash code.
   */
  virtual size_t hash_me() {
    for (size_t i = 0; i < size_; i++) {
      hash_ = hash_ * 67 + list_[i]->hash() * 13;
    }
    return hash_;
  }

  virtual Column *get_Column(size_t index) {
    assert(index < size_ && index >= 0);
    return list_[index];
  }
  // virtual void print_self() {
  //   for (size_t i = 0; i < size_; i++) {
  //     if (list_[i]) {
  //       list_[i]->print_self();
  //       puts("");
  //     }
  //   }
  // }
};